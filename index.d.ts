/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Configuration options for the formatter. */
export interface FormatOptions {
  /** Number of spaces per indent level (default: 4) */
  indentWidth?: number
  /** Use tabs instead of spaces for indentation (default: false) */
  useTabs?: boolean
  /** Preserve comments in output (default: true) */
  preserveComments?: boolean
  /** Sort imports alphabetically (default: true) */
  sortImports?: boolean
}
/**
 * Format SEA-DSL source code.
 *
 * @param source - The SEA-DSL source code to format
 * @param options - Optional formatting configuration
 * @returns The formatted source code
 * @throws Error if the source code cannot be parsed
 *
 * @example
 * ```typescript
 * import { formatSource } from '@domainforge/sea';
 *
 * const formatted = formatSource('Entity   "Foo"  in    bar');
 * console.log(formatted); // Entity "Foo" in bar
 * ```
 */
export declare function formatSource(source: string, options?: FormatOptions | undefined | null): string
/**
 * Check if SEA-DSL source code is already formatted.
 *
 * @param source - The SEA-DSL source code to check
 * @param options - Optional formatting configuration
 * @returns True if the source is already formatted, false otherwise
 * @throws Error if the source code cannot be parsed
 *
 * @example
 * ```typescript
 * import { checkFormat } from '@domainforge/sea';
 *
 * console.log(checkFormat('Entity "Foo" in bar
')); // true
 * console.log(checkFormat('Entity   "Foo"  in    bar')); // false
 * ```
 */
export declare function checkFormat(source: string, options?: FormatOptions | undefined | null): boolean
export const enum AggregateFunction {
  Count = 0,
  Sum = 1,
  Min = 2,
  Max = 3,
  Avg = 4
}
export const enum BinaryOp {
  And = 0,
  Or = 1,
  Equal = 2,
  NotEqual = 3,
  GreaterThan = 4,
  LessThan = 5,
  GreaterThanOrEqual = 6,
  LessThanOrEqual = 7,
  Plus = 8,
  Minus = 9,
  Multiply = 10,
  Divide = 11,
  Contains = 12,
  StartsWith = 13,
  EndsWith = 14,
  Matches = 15,
  HasRole = 16,
  Before = 17,
  After = 18,
  During = 19
}
export const enum UnaryOp {
  Not = 0,
  Negate = 1
}
export const enum Quantifier {
  ForAll = 0,
  Exists = 1,
  ExistsUnique = 2
}
/** Severity level for policy violations */
export const enum Severity {
  Error = 0,
  Warning = 1,
  Info = 2
}
export interface WindowSpec {
  duration: number
  unit: string
}
/** A policy violation */
export interface Violation {
  name: string
  message: string
  severity: Severity
}
/** Result of evaluating a policy against a graph */
export interface EvaluationResult {
  /** Backwards compatible boolean: false if evaluation is unknown (NULL) */
  isSatisfied: boolean
  /** Tri-state evaluation result: true, false, or null (NULL) */
  isSatisfiedTristate?: boolean
  /** List of violations */
  violations: Array<Violation>
}
export declare class Graph {
  constructor()
  addEntity(entity: Entity): void
  addResource(resource: Resource): void
  addFlow(flow: Flow): void
  addInstance(instance: ResourceInstance): void
  addRole(role: Role): void
  addRelation(relation: Relation): void
  entityCount(): number
  resourceCount(): number
  flowCount(): number
  instanceCount(): number
  patternCount(): number
  roleCount(): number
  relationCount(): number
  hasEntity(id: string): boolean
  hasResource(id: string): boolean
  hasFlow(id: string): boolean
  hasInstance(id: string): boolean
  getEntity(id: string): Entity | null
  getResource(id: string): Resource | null
  getFlow(id: string): Flow | null
  getInstance(id: string): ResourceInstance | null
  findRoleByName(name: string): string | null
  findEntityByName(name: string): string | null
  findResourceByName(name: string): string | null
  flowsFrom(entityId: string): Array<Flow>
  flowsTo(entityId: string): Array<Flow>
  allEntities(): Array<Entity>
  allResources(): Array<Resource>
  allFlows(): Array<Flow>
  allInstances(): Array<ResourceInstance>
  allRoles(): Array<Role>
  allRelations(): Array<Relation>
  static parse(source: string): Graph
  exportCalm(): string
  static importCalm(calmJson: string): Graph
  /**
   * Export the graph to Protobuf .proto text format.
   *
   * @param package - The Protobuf package name (e.g., "com.example.api")
   * @param namespace - Optional namespace filter (undefined = all namespaces)
   * @param projectionName - Optional name for the projection (used in comments)
   * @param includeGovernance - Whether to include governance messages (PolicyViolation, MetricEvent)
   * @param includeServices - Whether to generate gRPC service definitions from Flow patterns
   * @returns The generated .proto file content as a string
   */
  exportProtobuf(package: string, namespace?: string | undefined | null, projectionName?: string | undefined | null, includeGovernance?: boolean | undefined | null, includeServices?: boolean | undefined | null): string
  addPolicy(policyJson: string): void
  addAssociation(owner: string, owned: string, relType: string): void
  /**
   * Evaluate a Policy JSON payload against this Graph.
   *
   * The `policy_json` argument must be the JSON representation of `crate::policy::Policy`
   * (including fields like `id`, `name`, `modality`, `kind`, `version`, and `expression`).
   * Returns `EvaluationResult` exposed to TypeScript via napi, or an error if the policy JSON
   * is invalid or evaluation fails.
   */
  evaluatePolicy(policyJson: string): EvaluationResult
  /**
   * Set the evaluation mode for policy evaluation.
   * When `useThreeValuedLogic` is true, policies will use three-valued logic (true, false, null).
   * When false, policies will use strict boolean logic (true, false).
   */
  setEvaluationMode(useThreeValuedLogic: boolean): void
  /**
   * Get the current evaluation mode.
   * Returns true if three-valued logic is enabled, false otherwise.
   */
  useThreeValuedLogic(): boolean
  toString(): string
}
/** A policy expression that can be normalized and compared for equivalence. */
export declare class Expression {
  /** Create a literal expression from a JSON-compatible value (passed as JSON string). */
  static literal(valueJson: string): Expression
  /** Create a literal boolean expression. */
  static literalBool(value: boolean): Expression
  /** Create a literal number expression. */
  static literalNumber(value: number): Expression
  /** Create a literal string expression. */
  static literalString(value: string): Expression
  /** Create a variable expression. */
  static variable(name: string): Expression
  /** Create a quantity literal expression (e.g., "100 USD"). */
  static quantity(value: string, unit: string): Expression
  /** Create a time literal expression (ISO 8601 timestamp). */
  static time(timestamp: string): Expression
  /** Create an interval literal expression. */
  static interval(start: string, end: string): Expression
  /** Create a binary expression (e.g., left AND right). */
  static binary(op: BinaryOp, left: Expression, right: Expression): Expression
  /** Create a unary expression (e.g., NOT x). */
  static unary(op: UnaryOp, operand: Expression): Expression
  /** Create a cast expression (e.g., x as "Money"). */
  static cast(operand: Expression, targetType: string): Expression
  /** Create a quantifier expression (ForAll, Exists, ExistsUnique). */
  static quantifier(q: Quantifier, variable: string, collection: Expression, condition: Expression): Expression
  /** Create a member access expression (e.g., user.name). */
  static memberAccess(object: string, member: string): Expression
  /** Create an aggregation expression (e.g., COUNT(items)). */
  static aggregation(function: AggregateFunction, collection: Expression, field?: string | undefined | null, filter?: Expression | undefined | null): Expression
  /** Create an aggregation comprehension expression. */
  static aggregationComprehension(function: AggregateFunction, variable: string, collection: Expression, predicate: Expression, projection: Expression, window?: WindowSpec | undefined | null, targetUnit?: string | undefined | null): Expression
  /** Create a group-by expression. */
  static groupBy(variable: string, collection: Expression, key: Expression, condition: Expression, filter?: Expression | undefined | null): Expression
  /** Normalize this expression to canonical form. */
  normalize(): NormalizedExpression
  /** Check if this expression is semantically equivalent to another. */
  isEquivalent(other: Expression): boolean
  /** Get the string representation of this expression. */
  toStringRepr(): string
  /** Check equality with another expression. */
  equals(other: Expression): boolean
}
/** A normalized expression with a stable hash for caching and equivalence checks. */
export declare class NormalizedExpression {
  /** Get the stable hash value for this normalized expression as a string. */
  stableHash(): string
  /** Get the stable hash as a hex string. */
  stableHashHex(): string
  /** Get the inner expression. */
  innerExpression(): Expression
  /** Get the string representation of this normalized expression. */
  toStringRepr(): string
  /** Check equality with another normalized expression. */
  equals(other: NormalizedExpression): boolean
}
export declare class Entity {
  constructor(name: string, namespace?: string | undefined | null)
  get id(): string
  get name(): string
  get namespace(): string | null
  setAttribute(key: string, valueJson: string): void
  getAttribute(key: string): string | null
  toString(): string
}
export declare class Resource {
  constructor(name: string, unit: string, namespace?: string | undefined | null)
  get id(): string
  get name(): string
  get unit(): string
  get namespace(): string | null
  setAttribute(key: string, valueJson: string): void
  getAttribute(key: string): string | null
  toString(): string
}
export declare class Flow {
  constructor(resourceId: string, fromId: string, toId: string, quantity: number)
  get id(): string
  get resourceId(): string
  get fromId(): string
  get toId(): string
  get quantity(): number
  get namespace(): string | null
  setAttribute(key: string, valueJson: string): void
  getAttribute(key: string): string | null
  toString(): string
}
export declare class ResourceInstance {
  constructor(resourceId: string, entityId: string, namespace?: string | undefined | null)
  get id(): string
  get resourceId(): string
  get entityId(): string
  get namespace(): string | null
  setAttribute(key: string, valueJson: string): void
  getAttribute(key: string): string | null
  toString(): string
}
export declare class Instance {
  constructor(name: string, entityType: string, namespace?: string | undefined | null)
  get id(): string
  get name(): string
  get entityType(): string
  get namespace(): string | null
  setField(key: string, valueJson: string): void
  getField(key: string): string | null
  toString(): string
}
export declare class Metric {
  get name(): string
  get namespace(): string | null
  get threshold(): number | null
  get target(): number | null
  get unit(): string | null
  get severity(): string | null
}
export declare class Mapping {
  get name(): string
  get targetFormat(): string
}
export declare class Projection {
  get name(): string
  get targetFormat(): string
}
export declare class Role {
  constructor(name: string, namespace?: string | undefined | null)
  get id(): string
  get name(): string
  get namespace(): string | null
  setAttribute(key: string, valueJson: string): void
  getAttribute(key: string): string | null
  toString(): string
}
export declare class Relation {
  constructor(name: string, subjectRoleId: string, predicate: string, objectRoleId: string, namespace?: string | undefined | null, viaFlowId?: string | undefined | null)
  get id(): string
  get name(): string
  get namespace(): string
  get subjectRoleId(): string
  get predicate(): string
  get objectRoleId(): string
  get viaFlowId(): string | null
  toString(): string
}
export declare class NamespaceBinding {
  constructor(path: string, namespace: string)
  get path(): string
  get namespace(): string
}
export declare class NamespaceRegistry {
  static fromFile(path: string): NamespaceRegistry
  static discover(path: string): Self | null
  resolveFiles(failOnAmbiguity?: boolean | undefined | null): Array<NamespaceBinding>
  namespaceFor(path: string, failOnAmbiguity?: boolean | undefined | null): string
  get root(): string
  get defaultNamespace(): string
}
export declare class Dimension {
  static parse(name: string): Dimension
  get name(): string
}
export declare class Unit {
  constructor(symbol: string, name: string, dimension: string, baseFactor: number, baseUnit: string)
  get symbol(): string
  get name(): string
  get dimension(): string
  get baseFactor(): number
  get baseUnit(): string
}
