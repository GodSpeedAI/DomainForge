// SEA DSL Grammar Definition
// Based on the TypeScript Ohm-JS reference implementation

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Program is the top-level entry point
program = { SOI ~ declaration* ~ EOI }

// Declarations
declaration = { entity_decl | resource_decl | flow_decl | policy_decl }

// Entity Declaration
// Syntax: Entity "Name" in domain
// Syntax: Entity "Name"
entity_decl = {
    ^"entity" ~ name ~ (^"in" ~ identifier)?
}

// Resource Declaration
// Syntax: Resource "Name" units in domain
// Syntax: Resource "Name" in domain
// Syntax: Resource "Name" units
// Syntax: Resource "Name"
in_keyword = { ^"in" }

resource_decl = {
    ^"resource" ~ name ~ (
        (identifier ~ in_keyword ~ identifier) |  // "units in domain" - most specific first
        (in_keyword ~ identifier) |                // "in domain" - next most specific
        identifier                                 // "units" only - least specific last
    )?
}

// Flow Declaration
// Syntax: Flow "ResourceName" from "EntityA" to "EntityB" quantity 100
// Syntax: Flow "ResourceName" from "EntityA" to "EntityB"
flow_decl = {
    ^"flow" ~ string_literal ~ ^"from" ~ string_literal ~ ^"to" ~ string_literal ~ (^"quantity" ~ number)?
}

// Policy Declaration
// Syntax: Policy name as: expression
// Syntax: Policy name v1.0.0 as: expression
policy_decl = {
    ^"policy" ~ identifier ~ (^"v" ~ version)? ~ ^"as" ~ ":" ~ expression
}

// Semantic Version
version = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

// Expressions
expression = { or_expr }

or_expr = { and_expr ~ (^"or" ~ and_expr)* }

and_expr = { not_expr ~ (^"and" ~ not_expr)* }

not_expr = { (^"not" ~ not_expr) | comparison_expr }

comparison_expr = { additive_expr ~ (comparison_op ~ additive_expr)? }

comparison_op = {
    ">=" | "<=" | "!=" | "=" | ">" | "<" |
    ^"contains" | ^"startswith" | ^"endswith"
}

additive_expr = { multiplicative_expr ~ ((add_op ~ multiplicative_expr)*) }

add_op = { "+" | "-" }

multiplicative_expr = { unary_expr ~ ((mul_op ~ unary_expr)*) }

mul_op = { "*" | "/" }

unary_expr = { ("-" ~ unary_expr) | primary_expr }

primary_expr = {
    "(" ~ expression ~ ")" |
    aggregation_expr |
    quantified_expr |
    member_access |
    literal |
    identifier
}

// Aggregation expressions
// Syntax: count(flows)
// Syntax: sum(flows.quantity)
// Syntax: count(flows where resource = "Camera")
aggregation_expr = {
    aggregate_fn ~ "(" ~
        collection ~
        ("." ~ identifier)? ~
        (^"where" ~ expression)? ~
    ")"
}

aggregate_fn = {
    ^"count" | ^"sum" | ^"min" | ^"max" | ^"avg"
}

// Quantified expressions
// Syntax: forall x in Collection: (condition)
// Syntax: exists x in Collection: (condition)
quantified_expr = {
    quantifier ~ identifier ~ ^"in" ~ collection ~ ":" ~ "(" ~ expression ~ ")"
}

quantifier = { ^"exists_unique" | ^"forall" | ^"exists" }

collection = {
    ^"flows" | ^"entities" | ^"resources" | ^"instances"
}

// Member access (e.g., Flow.quantity, Entity.name)
member_access = { identifier ~ "." ~ identifier }

// Literals
literal = { multiline_string | string_literal | number | boolean }

// Name can be either a multiline string or regular string literal
name = { multiline_string | string_literal }

// Multi-line string with triple quotes
multiline_string = @{ "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" }

// String literal with escape sequences
string_literal = @{ "\"" ~ string_content* ~ "\"" }

string_content = @{
    escape_sequence |
    (!"\"" ~ !"\\" ~ ANY)
}

escape_sequence = @{
    "\\\\" |                                    // Backslash
    "\\\"" |                                    // Quote
    "\\n" |                                     // Newline
    "\\r" |                                     // Carriage return
    "\\t" |                                     // Tab
    ("\\u{" ~ ASCII_HEX_DIGIT{1,6} ~ "}")      // Unicode codepoint
}

number = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

boolean = { ^"true" | ^"false" }

// Identifier (Unicode support - letters, numbers, underscore)
// Must start with letter (including Unicode) or underscore
identifier = @{ (LETTER | "_") ~ (LETTER | NUMBER | "_")* }
