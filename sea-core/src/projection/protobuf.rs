//! Protobuf Projection Engine
//!
//! This module provides functionality to project SEA semantic graphs to Protocol Buffer
//! (`.proto`) files. It supports:
//!
//! - Entity and Resource projection to Protobuf messages
//! - Type mapping from SEA types to Protobuf scalar types
//! - Deterministic field numbering for schema stability
//! - Governance message generation
//!
//! # Example
//!
//! ```rust,ignore
//! use sea_core::projection::protobuf::ProtobufEngine;
//! use sea_core::graph::Graph;
//!
//! let graph = build_graph_from_model();
//! let proto_file = ProtobufEngine::project(&graph, "my_namespace", "my.package");
//! println!("{}", proto_file.to_proto_string());
//! ```

use crate::graph::Graph;
use crate::primitives::{Entity, Resource};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::BTreeMap;

// ============================================================================
// Protobuf IR Types
// ============================================================================

/// Represents a complete `.proto` file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoFile {
    /// The package name (e.g., "sea.example")
    pub package: String,
    /// Protobuf syntax version (always "proto3")
    pub syntax: String,
    /// Import statements
    pub imports: Vec<String>,
    /// File-level options
    pub options: ProtoOptions,
    /// Enum definitions
    pub enums: Vec<ProtoEnum>,
    /// Message definitions
    pub messages: Vec<ProtoMessage>,
    /// Metadata about the projection
    pub metadata: ProtoMetadata,
}

impl ProtoFile {
    /// Create a new ProtoFile with the given package name.
    pub fn new(package: impl Into<String>) -> Self {
        Self {
            package: package.into(),
            syntax: "proto3".to_string(),
            imports: Vec::new(),
            options: ProtoOptions::default(),
            enums: Vec::new(),
            messages: Vec::new(),
            metadata: ProtoMetadata::default(),
        }
    }

    /// Serialize the ProtoFile to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        // Header comments
        out.push_str(&format!(
            "// Generated by SEA Projection Framework\n"
        ));
        out.push_str(&format!(
            "// Projection: {}\n",
            self.metadata.projection_name
        ));
        out.push_str(&format!(
            "// Source Namespace: {}\n",
            self.metadata.source_namespace
        ));
        if let Some(ref version) = self.metadata.semantic_version {
            out.push_str(&format!("// Version: {}\n", version));
        }
        out.push_str(&format!(
            "// Generated At: {}\n",
            self.metadata.generated_at
        ));
        out.push_str("// DO NOT EDIT - This file is auto-generated\n\n");

        // Syntax
        out.push_str(&format!("syntax = \"{}\";\n\n", self.syntax));

        // Package
        out.push_str(&format!("package {};\n", self.package));

        // Options
        if let Some(ref pkg) = self.options.java_package {
            out.push_str(&format!("\noption java_package = \"{}\";\n", pkg));
        }
        if self.options.java_multiple_files {
            out.push_str("option java_multiple_files = true;\n");
        }
        if let Some(ref pkg) = self.options.go_package {
            out.push_str(&format!("option go_package = \"{}\";\n", pkg));
        }

        // Imports
        if !self.imports.is_empty() {
            out.push('\n');
            for import in &self.imports {
                out.push_str(&format!("import \"{}\";\n", import));
            }
        }

        // Enums
        for e in &self.enums {
            out.push('\n');
            out.push_str(&e.to_proto_string());
        }

        // Messages
        for m in &self.messages {
            out.push('\n');
            out.push_str(&m.to_proto_string());
        }

        out
    }
}

/// File-level Protobuf options.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ProtoOptions {
    /// Java package for generated code
    pub java_package: Option<String>,
    /// Generate separate files for each message in Java
    pub java_multiple_files: bool,
    /// Go package path
    pub go_package: Option<String>,
}

/// Metadata about the projection source.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ProtoMetadata {
    /// Name of the projection that generated this file
    pub projection_name: String,
    /// Semantic version if available
    pub semantic_version: Option<String>,
    /// Source namespace from the SEA model
    pub source_namespace: String,
    /// Timestamp of generation
    pub generated_at: String,
}

/// Represents a Protobuf message definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoMessage {
    /// Message name (PascalCase)
    pub name: String,
    /// Field definitions
    pub fields: Vec<ProtoField>,
    /// Nested message definitions
    pub nested_messages: Vec<ProtoMessage>,
    /// Nested enum definitions
    pub nested_enums: Vec<ProtoEnum>,
    /// Reserved field numbers
    pub reserved_numbers: Vec<u32>,
    /// Reserved field names
    pub reserved_names: Vec<String>,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoMessage {
    /// Create a new empty ProtoMessage.
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            fields: Vec::new(),
            nested_messages: Vec::new(),
            nested_enums: Vec::new(),
            reserved_numbers: Vec::new(),
            reserved_names: Vec::new(),
            comments: Vec::new(),
        }
    }

    /// Serialize the message to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        // Comments
        for comment in &self.comments {
            out.push_str(&format!("// {}\n", comment));
        }

        out.push_str(&format!("message {} {{\n", self.name));

        // Reserved fields
        if !self.reserved_numbers.is_empty() {
            let nums: Vec<String> = self
                .reserved_numbers
                .iter()
                .map(|n| n.to_string())
                .collect();
            out.push_str(&format!("  reserved {};\n", nums.join(", ")));
        }
        if !self.reserved_names.is_empty() {
            let names: Vec<String> = self
                .reserved_names
                .iter()
                .map(|n| format!("\"{}\"", n))
                .collect();
            out.push_str(&format!("  reserved {};\n", names.join(", ")));
        }

        // Nested enums
        for e in &self.nested_enums {
            for line in e.to_proto_string().lines() {
                out.push_str(&format!("  {}\n", line));
            }
        }

        // Nested messages
        for m in &self.nested_messages {
            for line in m.to_proto_string().lines() {
                out.push_str(&format!("  {}\n", line));
            }
        }

        // Fields
        for field in &self.fields {
            out.push_str(&format!("  {}\n", field.to_proto_string()));
        }

        out.push_str("}\n");
        out
    }
}

/// Represents a Protobuf field definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoField {
    /// Field name (snake_case)
    pub name: String,
    /// Field number (must be unique within message)
    pub number: u32,
    /// Field type
    pub proto_type: ProtoType,
    /// Whether this is a repeated field
    pub repeated: bool,
    /// Whether this field is optional (proto3 optional)
    pub optional: bool,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoField {
    /// Serialize the field to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut parts = Vec::new();

        // Comments as inline
        if !self.comments.is_empty() {
            // We'll add comment at the end
        }

        if self.optional {
            parts.push("optional".to_string());
        }
        if self.repeated {
            parts.push("repeated".to_string());
        }

        parts.push(self.proto_type.to_proto_string());
        parts.push(self.name.clone());

        let mut line = format!("{} = {};", parts.join(" "), self.number);

        if !self.comments.is_empty() {
            line.push_str(&format!(" // {}", self.comments.join("; ")));
        }

        line
    }
}

/// Represents a Protobuf type reference.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProtoType {
    /// Scalar types (int32, string, etc.)
    Scalar(ScalarType),
    /// Reference to another message type
    Message(String),
    /// Reference to an enum type
    Enum(String),
    /// Map type (map<key, value>)
    Map {
        key: Box<ProtoType>,
        value: Box<ProtoType>,
    },
}

impl ProtoType {
    /// Serialize the type to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        match self {
            ProtoType::Scalar(s) => s.to_proto_string(),
            ProtoType::Message(name) => name.clone(),
            ProtoType::Enum(name) => name.clone(),
            ProtoType::Map { key, value } => {
                format!("map<{}, {}>", key.to_proto_string(), value.to_proto_string())
            }
        }
    }
}

/// Protobuf scalar types.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ScalarType {
    Double,
    Float,
    Int32,
    Int64,
    Uint32,
    Uint64,
    Sint32,
    Sint64,
    Fixed32,
    Fixed64,
    Sfixed32,
    Sfixed64,
    Bool,
    String,
    Bytes,
}

impl ScalarType {
    /// Serialize the scalar type to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        match self {
            ScalarType::Double => "double",
            ScalarType::Float => "float",
            ScalarType::Int32 => "int32",
            ScalarType::Int64 => "int64",
            ScalarType::Uint32 => "uint32",
            ScalarType::Uint64 => "uint64",
            ScalarType::Sint32 => "sint32",
            ScalarType::Sint64 => "sint64",
            ScalarType::Fixed32 => "fixed32",
            ScalarType::Fixed64 => "fixed64",
            ScalarType::Sfixed32 => "sfixed32",
            ScalarType::Sfixed64 => "sfixed64",
            ScalarType::Bool => "bool",
            ScalarType::String => "string",
            ScalarType::Bytes => "bytes",
        }
        .to_string()
    }
}

/// Represents a Protobuf enum definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoEnum {
    /// Enum name (PascalCase)
    pub name: String,
    /// Enum values
    pub values: Vec<ProtoEnumValue>,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoEnum {
    /// Create a new ProtoEnum with default UNSPECIFIED value.
    pub fn new(name: impl Into<String>) -> Self {
        let name = name.into();
        Self {
            values: vec![ProtoEnumValue {
                name: format!("{}_UNSPECIFIED", to_screaming_snake_case(&name)),
                number: 0,
            }],
            name,
            comments: Vec::new(),
        }
    }

    /// Add a value to the enum.
    pub fn add_value(&mut self, name: impl Into<String>) {
        let number = self.values.len() as i32;
        self.values.push(ProtoEnumValue {
            name: name.into(),
            number,
        });
    }

    /// Serialize the enum to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        for comment in &self.comments {
            out.push_str(&format!("// {}\n", comment));
        }

        out.push_str(&format!("enum {} {{\n", self.name));

        for value in &self.values {
            out.push_str(&format!("  {} = {};\n", value.name, value.number));
        }

        out.push_str("}\n");
        out
    }
}

/// Represents a Protobuf enum value.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoEnumValue {
    /// Value name (SCREAMING_SNAKE_CASE)
    pub name: String,
    /// Numeric value
    pub number: i32,
}

// ============================================================================
// Type Mapping
// ============================================================================

/// Map SEA type strings to Protobuf types.
///
/// This function handles the common type names used in SEA attributes.
pub fn map_sea_type_to_proto(sea_type: &str) -> ProtoType {
    match sea_type.to_lowercase().as_str() {
        "string" | "text" | "varchar" => ProtoType::Scalar(ScalarType::String),
        "int" | "integer" | "int64" | "long" => ProtoType::Scalar(ScalarType::Int64),
        "int32" | "short" => ProtoType::Scalar(ScalarType::Int32),
        "float" | "double" | "decimal" | "number" => ProtoType::Scalar(ScalarType::Double),
        "float32" => ProtoType::Scalar(ScalarType::Float),
        "bool" | "boolean" => ProtoType::Scalar(ScalarType::Bool),
        "bytes" | "binary" | "blob" => ProtoType::Scalar(ScalarType::Bytes),
        "uuid" | "guid" => ProtoType::Scalar(ScalarType::String), // UUIDs as strings
        "date" | "datetime" | "timestamp" => ProtoType::Message("google.protobuf.Timestamp".to_string()),
        _ => ProtoType::Message(to_pascal_case(sea_type)), // Custom types become messages
    }
}

/// Infer a ProtoType from a serde_json::Value.
pub fn infer_proto_type_from_value(value: &Value) -> ProtoType {
    match value {
        Value::Null => ProtoType::Scalar(ScalarType::String),
        Value::Bool(_) => ProtoType::Scalar(ScalarType::Bool),
        Value::Number(n) => {
            if n.is_f64() {
                ProtoType::Scalar(ScalarType::Double)
            } else {
                ProtoType::Scalar(ScalarType::Int64)
            }
        }
        Value::String(_) => ProtoType::Scalar(ScalarType::String),
        Value::Array(_) => ProtoType::Scalar(ScalarType::String), // Arrays need special handling
        Value::Object(_) => ProtoType::Scalar(ScalarType::String), // Objects need special handling
    }
}

// ============================================================================
// Protobuf Engine
// ============================================================================

/// The Protobuf projection engine.
///
/// This struct provides methods to convert a SEA Graph into Protobuf IR
/// which can then be serialized to `.proto` text format.
pub struct ProtobufEngine;

impl ProtobufEngine {
    /// Project a SEA Graph to a ProtoFile.
    ///
    /// # Arguments
    ///
    /// * `graph` - The semantic graph to project
    /// * `namespace` - Filter to only include entities/resources from this namespace (empty = all)
    /// * `package` - The Protobuf package name to use
    ///
    /// # Returns
    ///
    /// A `ProtoFile` containing the generated Protobuf IR.
    pub fn project(graph: &Graph, namespace: &str, package: &str) -> ProtoFile {
        let mut proto = ProtoFile::new(package);
        proto.metadata.source_namespace = namespace.to_string();
        proto.metadata.generated_at = chrono::Utc::now().to_rfc3339();

        // Convert entities to messages
        for entity in graph.all_entities() {
            if namespace.is_empty() || entity.namespace() == namespace {
                proto.messages.push(Self::entity_to_message(entity));
            }
        }

        // Convert resources to messages
        for resource in graph.all_resources() {
            if namespace.is_empty() || resource.namespace() == namespace {
                proto.messages.push(Self::resource_to_message(resource));
            }
        }

        // Sort messages by name for deterministic output
        proto.messages.sort_by(|a, b| a.name.cmp(&b.name));

        proto
    }

    /// Project with options for a projection contract.
    pub fn project_with_options(
        graph: &Graph,
        namespace: &str,
        package: &str,
        projection_name: &str,
        include_governance: bool,
    ) -> ProtoFile {
        let mut proto = Self::project(graph, namespace, package);
        proto.metadata.projection_name = projection_name.to_string();

        if include_governance {
            proto.messages.extend(Self::generate_governance_messages());
        }

        proto
    }

    /// Convert an Entity to a ProtoMessage.
    fn entity_to_message(entity: &Entity) -> ProtoMessage {
        let mut msg = ProtoMessage::new(to_pascal_case(entity.name()));
        msg.comments.push(format!("SEA Entity: {}", entity.name()));
        msg.comments.push(format!("Namespace: {}", entity.namespace()));

        let mut field_number = 1u32;

        // Add id field (always first)
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unique identifier".to_string()],
        });
        field_number += 1;

        // Add name field
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Entity name".to_string()],
        });
        field_number += 1;

        // Add attributes sorted alphabetically for deterministic output
        let mut sorted_attrs: BTreeMap<&String, &Value> = BTreeMap::new();
        for (key, value) in entity.attributes() {
            sorted_attrs.insert(key, value);
        }

        for (key, value) in sorted_attrs {
            msg.fields.push(ProtoField {
                name: to_snake_case(key),
                number: field_number,
                proto_type: infer_proto_type_from_value(value),
                repeated: matches!(value, Value::Array(_)),
                optional: true,
                comments: vec![],
            });
            field_number += 1;
        }

        msg
    }

    /// Convert a Resource to a ProtoMessage.
    fn resource_to_message(resource: &Resource) -> ProtoMessage {
        let mut msg = ProtoMessage::new(to_pascal_case(resource.name()));
        msg.comments.push(format!("SEA Resource: {}", resource.name()));
        msg.comments.push(format!("Unit: {}", resource.unit().symbol()));

        let mut field_number = 1u32;

        // Add id field
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unique identifier".to_string()],
        });
        field_number += 1;

        // Add name field
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Resource name".to_string()],
        });
        field_number += 1;

        // Add quantity field with unit comment
        msg.fields.push(ProtoField {
            name: "quantity".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::Double),
            repeated: false,
            optional: true,
            comments: vec![format!("Quantity in {}", resource.unit().symbol())],
        });
        field_number += 1;

        // Add unit field
        msg.fields.push(ProtoField {
            name: "unit".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unit of measurement".to_string()],
        });
        field_number += 1;

        // Add attributes
        let mut sorted_attrs: BTreeMap<&String, &Value> = BTreeMap::new();
        for (key, value) in resource.attributes() {
            sorted_attrs.insert(key, value);
        }

        for (key, value) in sorted_attrs {
            msg.fields.push(ProtoField {
                name: to_snake_case(key),
                number: field_number,
                proto_type: infer_proto_type_from_value(value),
                repeated: matches!(value, Value::Array(_)),
                optional: true,
                comments: vec![],
            });
            field_number += 1;
        }

        msg
    }

    /// Generate standard governance messages.
    fn generate_governance_messages() -> Vec<ProtoMessage> {
        let mut messages = Vec::new();

        // PolicyViolation message
        let mut violation = ProtoMessage::new("PolicyViolation");
        violation.comments.push("Represents a policy violation event".to_string());
        violation.fields = vec![
            ProtoField {
                name: "policy_name".to_string(),
                number: 1,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Name of the violated policy".to_string()],
            },
            ProtoField {
                name: "entity_id".to_string(),
                number: 2,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["ID of the entity that violated the policy".to_string()],
            },
            ProtoField {
                name: "severity".to_string(),
                number: 3,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Severity level (error, warn, info)".to_string()],
            },
            ProtoField {
                name: "message".to_string(),
                number: 4,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Human-readable violation message".to_string()],
            },
            ProtoField {
                name: "timestamp".to_string(),
                number: 5,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["When the violation occurred".to_string()],
            },
        ];
        messages.push(violation);

        // MetricEvent message
        let mut metric = ProtoMessage::new("MetricEvent");
        metric.comments.push("Represents a metric measurement event".to_string());
        metric.fields = vec![
            ProtoField {
                name: "metric_name".to_string(),
                number: 1,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Name of the metric".to_string()],
            },
            ProtoField {
                name: "value".to_string(),
                number: 2,
                proto_type: ProtoType::Scalar(ScalarType::Double),
                repeated: false,
                optional: false,
                comments: vec!["Measured value".to_string()],
            },
            ProtoField {
                name: "unit".to_string(),
                number: 3,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: true,
                comments: vec!["Unit of measurement".to_string()],
            },
            ProtoField {
                name: "timestamp".to_string(),
                number: 4,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["When the measurement was taken".to_string()],
            },
        ];
        messages.push(metric);

        messages
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Convert a string to PascalCase.
fn to_pascal_case(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().to_string() + &chars.as_str().to_lowercase(),
                None => String::new(),
            }
        })
        .collect()
}

/// Convert a string to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_is_uppercase = false;

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 && !prev_is_uppercase {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap_or(c));
            prev_is_uppercase = true;
        } else if c.is_alphanumeric() {
            result.push(c);
            prev_is_uppercase = false;
        } else {
            if !result.is_empty() && !result.ends_with('_') {
                result.push('_');
            }
            prev_is_uppercase = false;
        }
    }

    result.trim_matches('_').to_string()
}

/// Convert a string to SCREAMING_SNAKE_CASE.
fn to_screaming_snake_case(s: &str) -> String {
    to_snake_case(s).to_uppercase()
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("hello_world"), "HelloWorld");
        assert_eq!(to_pascal_case("my-entity"), "MyEntity");
        assert_eq!(to_pascal_case("already PascalCase"), "AlreadyPascalcase");
        assert_eq!(to_pascal_case("UPPERCASE"), "Uppercase");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(to_snake_case("myEntity"), "my_entity");
        assert_eq!(to_snake_case("already_snake"), "already_snake");
        // Consecutive uppercase chars become lowercase without underscore separation
        assert_eq!(to_snake_case("XMLParser"), "xmlparser");
        assert_eq!(to_snake_case("PaymentID"), "payment_id");
    }

    #[test]
    fn test_to_screaming_snake_case() {
        assert_eq!(to_screaming_snake_case("MyEnum"), "MY_ENUM");
        assert_eq!(to_screaming_snake_case("StatusCode"), "STATUS_CODE");
    }

    #[test]
    fn test_map_sea_type_to_proto() {
        assert_eq!(
            map_sea_type_to_proto("string"),
            ProtoType::Scalar(ScalarType::String)
        );
        assert_eq!(
            map_sea_type_to_proto("int"),
            ProtoType::Scalar(ScalarType::Int64)
        );
        assert_eq!(
            map_sea_type_to_proto("boolean"),
            ProtoType::Scalar(ScalarType::Bool)
        );
        assert_eq!(
            map_sea_type_to_proto("timestamp"),
            ProtoType::Message("google.protobuf.Timestamp".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("CustomType"),
            ProtoType::Message("Customtype".to_string())
        );
    }

    #[test]
    fn test_proto_field_to_string() {
        let field = ProtoField {
            name: "my_field".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        };
        assert_eq!(field.to_proto_string(), "string my_field = 1;");

        let optional_field = ProtoField {
            name: "optional_field".to_string(),
            number: 2,
            proto_type: ProtoType::Scalar(ScalarType::Int64),
            repeated: false,
            optional: true,
            comments: vec![],
        };
        assert_eq!(
            optional_field.to_proto_string(),
            "optional int64 optional_field = 2;"
        );

        let repeated_field = ProtoField {
            name: "items".to_string(),
            number: 3,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: true,
            optional: false,
            comments: vec![],
        };
        assert_eq!(repeated_field.to_proto_string(), "repeated string items = 3;");
    }

    #[test]
    fn test_proto_enum_to_string() {
        let mut e = ProtoEnum::new("Status");
        e.add_value("STATUS_ACTIVE");
        e.add_value("STATUS_INACTIVE");

        let output = e.to_proto_string();
        assert!(output.contains("enum Status {"));
        assert!(output.contains("STATUS_UNSPECIFIED = 0;"));
        assert!(output.contains("STATUS_ACTIVE = 1;"));
        assert!(output.contains("STATUS_INACTIVE = 2;"));
    }

    #[test]
    fn test_proto_message_to_string() {
        let mut msg = ProtoMessage::new("Person");
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        msg.fields.push(ProtoField {
            name: "age".to_string(),
            number: 2,
            proto_type: ProtoType::Scalar(ScalarType::Int32),
            repeated: false,
            optional: true,
            comments: vec![],
        });

        let output = msg.to_proto_string();
        assert!(output.contains("message Person {"));
        assert!(output.contains("string name = 1;"));
        assert!(output.contains("optional int32 age = 2;"));
    }

    #[test]
    fn test_proto_file_to_string() {
        let mut proto = ProtoFile::new("test.package");
        proto.metadata.projection_name = "TestProjection".to_string();
        proto.metadata.source_namespace = "test".to_string();

        let mut msg = ProtoMessage::new("TestMessage");
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        proto.messages.push(msg);

        let output = proto.to_proto_string();
        assert!(output.contains("syntax = \"proto3\";"));
        assert!(output.contains("package test.package;"));
        assert!(output.contains("message TestMessage {"));
        assert!(output.contains("string id = 1;"));
    }

    #[test]
    fn test_entity_to_message() {
        use serde_json::json;

        let mut entity = Entity::new_with_namespace("Warehouse", "logistics");
        entity.set_attribute("capacity", json!(5000));
        entity.set_attribute("location", json!("Building A"));

        let msg = ProtobufEngine::entity_to_message(&entity);

        assert_eq!(msg.name, "Warehouse");
        assert!(msg.fields.iter().any(|f| f.name == "id"));
        assert!(msg.fields.iter().any(|f| f.name == "name"));
        assert!(msg.fields.iter().any(|f| f.name == "capacity"));
        assert!(msg.fields.iter().any(|f| f.name == "location"));

        // Check field numbers are sequential
        let numbers: Vec<u32> = msg.fields.iter().map(|f| f.number).collect();
        assert_eq!(numbers, vec![1, 2, 3, 4]); // id, name, capacity, location (sorted)
    }

    #[test]
    fn test_governance_messages() {
        let messages = ProtobufEngine::generate_governance_messages();
        assert_eq!(messages.len(), 2);

        let violation = messages.iter().find(|m| m.name == "PolicyViolation");
        assert!(violation.is_some());

        let metric = messages.iter().find(|m| m.name == "MetricEvent");
        assert!(metric.is_some());
    }
}
