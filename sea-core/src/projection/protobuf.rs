//! Protobuf Projection Engine
//!
//! This module provides functionality to project SEA semantic graphs to Protocol Buffer
//! (`.proto`) files. It supports:
//!
//! - Entity and Resource projection to Protobuf messages
//! - Type mapping from SEA types to Protobuf scalar types
//! - Deterministic field numbering for schema stability
//! - Governance message generation
//!
//! # Example
//!
//! ```rust,ignore
//! use sea_core::projection::protobuf::ProtobufEngine;
//! use sea_core::graph::Graph;
//!
//! let graph = build_graph_from_model();
//! let proto_file = ProtobufEngine::project(&graph, "my_namespace", "my.package");
//! println!("{}", proto_file.to_proto_string());
//! ```

use crate::graph::Graph;
use crate::primitives::{Entity, Resource};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::BTreeMap;

// ============================================================================
// Protobuf IR Types
// ============================================================================

/// Represents a complete `.proto` file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoFile {
    /// The package name (e.g., "sea.example")
    pub package: String,
    /// Protobuf syntax version (always "proto3")
    pub syntax: String,
    /// Import statements
    pub imports: Vec<String>,
    /// File-level options
    pub options: ProtoOptions,
    /// Enum definitions
    pub enums: Vec<ProtoEnum>,
    /// Message definitions
    pub messages: Vec<ProtoMessage>,
    /// Metadata about the projection
    pub metadata: ProtoMetadata,
}

impl ProtoFile {
    /// Create a new ProtoFile with the given package name.
    pub fn new(package: impl Into<String>) -> Self {
        Self {
            package: package.into(),
            syntax: "proto3".to_string(),
            imports: Vec::new(),
            options: ProtoOptions::default(),
            enums: Vec::new(),
            messages: Vec::new(),
            metadata: ProtoMetadata::default(),
        }
    }

    /// Serialize the ProtoFile to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        // Header comments
        out.push_str(&format!(
            "// Generated by SEA Projection Framework\n"
        ));
        out.push_str(&format!(
            "// Projection: {}\n",
            self.metadata.projection_name
        ));
        out.push_str(&format!(
            "// Source Namespace: {}\n",
            self.metadata.source_namespace
        ));
        if let Some(ref version) = self.metadata.semantic_version {
            out.push_str(&format!("// Version: {}\n", version));
        }
        out.push_str(&format!(
            "// Generated At: {}\n",
            self.metadata.generated_at
        ));
        out.push_str("// DO NOT EDIT - This file is auto-generated\n\n");

        // Syntax
        out.push_str(&format!("syntax = \"{}\";\n\n", self.syntax));

        // Package
        out.push_str(&format!("package {};\n", self.package));

        // Options
        if let Some(ref pkg) = self.options.java_package {
            out.push_str(&format!("\noption java_package = \"{}\";\n", pkg));
        }
        if self.options.java_multiple_files {
            out.push_str("option java_multiple_files = true;\n");
        }
        if let Some(ref pkg) = self.options.go_package {
            out.push_str(&format!("option go_package = \"{}\";\n", pkg));
        }

        // Imports
        if !self.imports.is_empty() {
            out.push('\n');
            for import in &self.imports {
                out.push_str(&format!("import \"{}\";\n", import));
            }
        }

        // Enums
        for e in &self.enums {
            out.push('\n');
            out.push_str(&e.to_proto_string());
        }

        // Messages
        for m in &self.messages {
            out.push('\n');
            out.push_str(&m.to_proto_string());
        }

        out
    }

    /// Scan all messages and automatically add required Well-Known Type imports.
    ///
    /// This method should be called after all messages are added to ensure
    /// proper imports are included for any WKT fields.
    pub fn add_wkt_imports(&mut self) {
        use std::collections::HashSet;
        let mut required_imports: HashSet<&'static str> = HashSet::new();

        // Scan all message fields for WKT references
        for msg in &self.messages {
            Self::collect_wkt_imports_from_message(msg, &mut required_imports);
        }

        // Add imports that aren't already present
        for import in required_imports {
            if !self.imports.contains(&import.to_string()) {
                self.imports.push(import.to_string());
            }
        }

        // Sort imports for deterministic output
        self.imports.sort();
    }

    fn collect_wkt_imports_from_message(msg: &ProtoMessage, imports: &mut std::collections::HashSet<&'static str>) {
        for field in &msg.fields {
            if let ProtoType::Message(ref type_name) = field.proto_type {
                if let Some(wkt) = WellKnownType::from_type_name(type_name) {
                    imports.insert(wkt.import_path());
                }
            }
        }

        // Recurse into nested messages
        for nested in &msg.nested_messages {
            Self::collect_wkt_imports_from_message(nested, imports);
        }
    }
}

/// File-level Protobuf options.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ProtoOptions {
    /// Java package for generated code
    pub java_package: Option<String>,
    /// Generate separate files for each message in Java
    pub java_multiple_files: bool,
    /// Go package path
    pub go_package: Option<String>,
}

/// Metadata about the projection source.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ProtoMetadata {
    /// Name of the projection that generated this file
    pub projection_name: String,
    /// Semantic version if available
    pub semantic_version: Option<String>,
    /// Source namespace from the SEA model
    pub source_namespace: String,
    /// Timestamp of generation
    pub generated_at: String,
}

/// Represents a Protobuf message definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoMessage {
    /// Message name (PascalCase)
    pub name: String,
    /// Field definitions
    pub fields: Vec<ProtoField>,
    /// Nested message definitions
    pub nested_messages: Vec<ProtoMessage>,
    /// Nested enum definitions
    pub nested_enums: Vec<ProtoEnum>,
    /// Reserved field numbers
    pub reserved_numbers: Vec<u32>,
    /// Reserved field names
    pub reserved_names: Vec<String>,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoMessage {
    /// Create a new empty ProtoMessage.
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            fields: Vec::new(),
            nested_messages: Vec::new(),
            nested_enums: Vec::new(),
            reserved_numbers: Vec::new(),
            reserved_names: Vec::new(),
            comments: Vec::new(),
        }
    }

    /// Serialize the message to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        // Comments
        for comment in &self.comments {
            out.push_str(&format!("// {}\n", comment));
        }

        out.push_str(&format!("message {} {{\n", self.name));

        // Reserved fields
        if !self.reserved_numbers.is_empty() {
            let nums: Vec<String> = self
                .reserved_numbers
                .iter()
                .map(|n| n.to_string())
                .collect();
            out.push_str(&format!("  reserved {};\n", nums.join(", ")));
        }
        if !self.reserved_names.is_empty() {
            let names: Vec<String> = self
                .reserved_names
                .iter()
                .map(|n| format!("\"{}\"", n))
                .collect();
            out.push_str(&format!("  reserved {};\n", names.join(", ")));
        }

        // Nested enums
        for e in &self.nested_enums {
            for line in e.to_proto_string().lines() {
                out.push_str(&format!("  {}\n", line));
            }
        }

        // Nested messages
        for m in &self.nested_messages {
            for line in m.to_proto_string().lines() {
                out.push_str(&format!("  {}\n", line));
            }
        }

        // Fields
        for field in &self.fields {
            out.push_str(&format!("  {}\n", field.to_proto_string()));
        }

        out.push_str("}\n");
        out
    }
}

/// Represents a Protobuf field definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoField {
    /// Field name (snake_case)
    pub name: String,
    /// Field number (must be unique within message)
    pub number: u32,
    /// Field type
    pub proto_type: ProtoType,
    /// Whether this is a repeated field
    pub repeated: bool,
    /// Whether this field is optional (proto3 optional)
    pub optional: bool,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoField {
    /// Serialize the field to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut parts = Vec::new();

        // Comments as inline
        if !self.comments.is_empty() {
            // We'll add comment at the end
        }

        if self.optional {
            parts.push("optional".to_string());
        }
        if self.repeated {
            parts.push("repeated".to_string());
        }

        parts.push(self.proto_type.to_proto_string());
        parts.push(self.name.clone());

        let mut line = format!("{} = {};", parts.join(" "), self.number);

        if !self.comments.is_empty() {
            line.push_str(&format!(" // {}", self.comments.join("; ")));
        }

        line
    }
}

/// Represents a Protobuf type reference.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProtoType {
    /// Scalar types (int32, string, etc.)
    Scalar(ScalarType),
    /// Reference to another message type
    Message(String),
    /// Reference to an enum type
    Enum(String),
    /// Map type (map<key, value>)
    Map {
        key: Box<ProtoType>,
        value: Box<ProtoType>,
    },
}

impl ProtoType {
    /// Serialize the type to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        match self {
            ProtoType::Scalar(s) => s.to_proto_string(),
            ProtoType::Message(name) => name.clone(),
            ProtoType::Enum(name) => name.clone(),
            ProtoType::Map { key, value } => {
                format!("map<{}, {}>", key.to_proto_string(), value.to_proto_string())
            }
        }
    }
}

/// Protobuf scalar types.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ScalarType {
    Double,
    Float,
    Int32,
    Int64,
    Uint32,
    Uint64,
    Sint32,
    Sint64,
    Fixed32,
    Fixed64,
    Sfixed32,
    Sfixed64,
    Bool,
    String,
    Bytes,
}

impl ScalarType {
    /// Serialize the scalar type to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        match self {
            ScalarType::Double => "double",
            ScalarType::Float => "float",
            ScalarType::Int32 => "int32",
            ScalarType::Int64 => "int64",
            ScalarType::Uint32 => "uint32",
            ScalarType::Uint64 => "uint64",
            ScalarType::Sint32 => "sint32",
            ScalarType::Sint64 => "sint64",
            ScalarType::Fixed32 => "fixed32",
            ScalarType::Fixed64 => "fixed64",
            ScalarType::Sfixed32 => "sfixed32",
            ScalarType::Sfixed64 => "sfixed64",
            ScalarType::Bool => "bool",
            ScalarType::String => "string",
            ScalarType::Bytes => "bytes",
        }
        .to_string()
    }
}

/// Represents a Protobuf enum definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoEnum {
    /// Enum name (PascalCase)
    pub name: String,
    /// Enum values
    pub values: Vec<ProtoEnumValue>,
    /// Documentation comments
    pub comments: Vec<String>,
}

impl ProtoEnum {
    /// Create a new ProtoEnum with default UNSPECIFIED value.
    pub fn new(name: impl Into<String>) -> Self {
        let name = name.into();
        Self {
            values: vec![ProtoEnumValue {
                name: format!("{}_UNSPECIFIED", to_screaming_snake_case(&name)),
                number: 0,
            }],
            name,
            comments: Vec::new(),
        }
    }

    /// Add a value to the enum.
    pub fn add_value(&mut self, name: impl Into<String>) {
        let number = self.values.len() as i32;
        self.values.push(ProtoEnumValue {
            name: name.into(),
            number,
        });
    }

    /// Serialize the enum to `.proto` text format.
    pub fn to_proto_string(&self) -> String {
        let mut out = String::new();

        for comment in &self.comments {
            out.push_str(&format!("// {}\n", comment));
        }

        out.push_str(&format!("enum {} {{\n", self.name));

        for value in &self.values {
            out.push_str(&format!("  {} = {};\n", value.name, value.number));
        }

        out.push_str("}\n");
        out
    }
}

/// Represents a Protobuf enum value.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtoEnumValue {
    /// Value name (SCREAMING_SNAKE_CASE)
    pub name: String,
    /// Numeric value
    pub number: i32,
}

// ============================================================================
// Well-Known Types
// ============================================================================

/// Google Protobuf Well-Known Types.
///
/// These are standard types provided by Google that have special handling
/// in most Protobuf implementations.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum WellKnownType {
    /// google.protobuf.Timestamp - for date/time values
    Timestamp,
    /// google.protobuf.Duration - for time spans
    Duration,
    /// google.protobuf.Any - for dynamic typing
    Any,
    /// google.protobuf.Struct - for JSON-like structures
    Struct,
    /// google.protobuf.Value - for dynamic JSON values
    Value,
    /// google.protobuf.ListValue - for JSON arrays
    ListValue,
    /// google.protobuf.Empty - for empty messages
    Empty,
    /// Wrapper types for nullable primitives
    Int32Value,
    Int64Value,
    UInt32Value,
    UInt64Value,
    FloatValue,
    DoubleValue,
    BoolValue,
    StringValue,
    BytesValue,
}

impl WellKnownType {
    /// Get the fully qualified type name.
    pub fn type_name(&self) -> &'static str {
        match self {
            WellKnownType::Timestamp => "google.protobuf.Timestamp",
            WellKnownType::Duration => "google.protobuf.Duration",
            WellKnownType::Any => "google.protobuf.Any",
            WellKnownType::Struct => "google.protobuf.Struct",
            WellKnownType::Value => "google.protobuf.Value",
            WellKnownType::ListValue => "google.protobuf.ListValue",
            WellKnownType::Empty => "google.protobuf.Empty",
            WellKnownType::Int32Value => "google.protobuf.Int32Value",
            WellKnownType::Int64Value => "google.protobuf.Int64Value",
            WellKnownType::UInt32Value => "google.protobuf.UInt32Value",
            WellKnownType::UInt64Value => "google.protobuf.UInt64Value",
            WellKnownType::FloatValue => "google.protobuf.FloatValue",
            WellKnownType::DoubleValue => "google.protobuf.DoubleValue",
            WellKnownType::BoolValue => "google.protobuf.BoolValue",
            WellKnownType::StringValue => "google.protobuf.StringValue",
            WellKnownType::BytesValue => "google.protobuf.BytesValue",
        }
    }

    /// Get the import path for this type.
    pub fn import_path(&self) -> &'static str {
        match self {
            WellKnownType::Timestamp => "google/protobuf/timestamp.proto",
            WellKnownType::Duration => "google/protobuf/duration.proto",
            WellKnownType::Any => "google/protobuf/any.proto",
            WellKnownType::Struct | WellKnownType::Value | WellKnownType::ListValue => {
                "google/protobuf/struct.proto"
            }
            WellKnownType::Empty => "google/protobuf/empty.proto",
            WellKnownType::Int32Value
            | WellKnownType::Int64Value
            | WellKnownType::UInt32Value
            | WellKnownType::UInt64Value
            | WellKnownType::FloatValue
            | WellKnownType::DoubleValue
            | WellKnownType::BoolValue
            | WellKnownType::StringValue
            | WellKnownType::BytesValue => "google/protobuf/wrappers.proto",
        }
    }

    /// Try to parse a type name into a WellKnownType.
    pub fn from_type_name(name: &str) -> Option<Self> {
        match name {
            "google.protobuf.Timestamp" => Some(WellKnownType::Timestamp),
            "google.protobuf.Duration" => Some(WellKnownType::Duration),
            "google.protobuf.Any" => Some(WellKnownType::Any),
            "google.protobuf.Struct" => Some(WellKnownType::Struct),
            "google.protobuf.Value" => Some(WellKnownType::Value),
            "google.protobuf.ListValue" => Some(WellKnownType::ListValue),
            "google.protobuf.Empty" => Some(WellKnownType::Empty),
            "google.protobuf.Int32Value" => Some(WellKnownType::Int32Value),
            "google.protobuf.Int64Value" => Some(WellKnownType::Int64Value),
            "google.protobuf.UInt32Value" => Some(WellKnownType::UInt32Value),
            "google.protobuf.UInt64Value" => Some(WellKnownType::UInt64Value),
            "google.protobuf.FloatValue" => Some(WellKnownType::FloatValue),
            "google.protobuf.DoubleValue" => Some(WellKnownType::DoubleValue),
            "google.protobuf.BoolValue" => Some(WellKnownType::BoolValue),
            "google.protobuf.StringValue" => Some(WellKnownType::StringValue),
            "google.protobuf.BytesValue" => Some(WellKnownType::BytesValue),
            _ => None,
        }
    }
}

// ============================================================================
// Type Mapping
// ============================================================================

/// Map SEA type strings to Protobuf types.
///
/// This function handles the common type names used in SEA attributes,
/// including mapping to Google Well-Known Types where appropriate.
pub fn map_sea_type_to_proto(sea_type: &str) -> ProtoType {
    match sea_type.to_lowercase().as_str() {
        // Scalar types
        "string" | "text" | "varchar" => ProtoType::Scalar(ScalarType::String),
        "int" | "integer" | "int64" | "long" => ProtoType::Scalar(ScalarType::Int64),
        "int32" | "short" => ProtoType::Scalar(ScalarType::Int32),
        "uint32" => ProtoType::Scalar(ScalarType::Uint32),
        "uint64" | "ulong" => ProtoType::Scalar(ScalarType::Uint64),
        "float" | "double" | "decimal" | "number" => ProtoType::Scalar(ScalarType::Double),
        "float32" => ProtoType::Scalar(ScalarType::Float),
        "bool" | "boolean" => ProtoType::Scalar(ScalarType::Bool),
        "bytes" | "binary" | "blob" => ProtoType::Scalar(ScalarType::Bytes),
        "uuid" | "guid" => ProtoType::Scalar(ScalarType::String),

        // Well-Known Types
        "date" | "datetime" | "timestamp" => {
            ProtoType::Message(WellKnownType::Timestamp.type_name().to_string())
        }
        "duration" | "timespan" | "interval" => {
            ProtoType::Message(WellKnownType::Duration.type_name().to_string())
        }
        "any" | "dynamic" | "object" => {
            ProtoType::Message(WellKnownType::Any.type_name().to_string())
        }
        "struct" | "json" | "jsonobject" => {
            ProtoType::Message(WellKnownType::Struct.type_name().to_string())
        }
        "value" | "jsonvalue" => {
            ProtoType::Message(WellKnownType::Value.type_name().to_string())
        }
        "empty" | "void" | "unit" => {
            ProtoType::Message(WellKnownType::Empty.type_name().to_string())
        }

        // Nullable wrapper types
        "optional_int" | "nullable_int" | "int?" => {
            ProtoType::Message(WellKnownType::Int64Value.type_name().to_string())
        }
        "optional_int32" | "nullable_int32" | "int32?" => {
            ProtoType::Message(WellKnownType::Int32Value.type_name().to_string())
        }
        "optional_string" | "nullable_string" | "string?" => {
            ProtoType::Message(WellKnownType::StringValue.type_name().to_string())
        }
        "optional_bool" | "nullable_bool" | "bool?" => {
            ProtoType::Message(WellKnownType::BoolValue.type_name().to_string())
        }
        "optional_double" | "nullable_double" | "double?" => {
            ProtoType::Message(WellKnownType::DoubleValue.type_name().to_string())
        }
        "optional_float" | "nullable_float" | "float?" => {
            ProtoType::Message(WellKnownType::FloatValue.type_name().to_string())
        }
        "optional_bytes" | "nullable_bytes" | "bytes?" => {
            ProtoType::Message(WellKnownType::BytesValue.type_name().to_string())
        }

        // Custom types become messages
        _ => ProtoType::Message(to_pascal_case(sea_type)),
    }
}

/// Infer a ProtoType from a serde_json::Value.
pub fn infer_proto_type_from_value(value: &Value) -> ProtoType {
    match value {
        Value::Null => ProtoType::Scalar(ScalarType::String),
        Value::Bool(_) => ProtoType::Scalar(ScalarType::Bool),
        Value::Number(n) => {
            if n.is_f64() {
                ProtoType::Scalar(ScalarType::Double)
            } else {
                ProtoType::Scalar(ScalarType::Int64)
            }
        }
        Value::String(_) => ProtoType::Scalar(ScalarType::String),
        Value::Array(_) => ProtoType::Scalar(ScalarType::String), // Arrays need special handling
        Value::Object(_) => ProtoType::Scalar(ScalarType::String), // Objects need special handling
    }
}

// ============================================================================
// Protobuf Engine
// ============================================================================

/// The Protobuf projection engine.
///
/// This struct provides methods to convert a SEA Graph into Protobuf IR
/// which can then be serialized to `.proto` text format.
pub struct ProtobufEngine;

impl ProtobufEngine {
    /// Project a SEA Graph to a ProtoFile.
    ///
    /// # Arguments
    ///
    /// * `graph` - The semantic graph to project
    /// * `namespace` - Filter to only include entities/resources from this namespace (empty = all)
    /// * `package` - The Protobuf package name to use
    ///
    /// # Returns
    ///
    /// A `ProtoFile` containing the generated Protobuf IR.
    pub fn project(graph: &Graph, namespace: &str, package: &str) -> ProtoFile {
        let mut proto = ProtoFile::new(package);
        proto.metadata.source_namespace = namespace.to_string();
        proto.metadata.generated_at = chrono::Utc::now().to_rfc3339();

        // Convert entities to messages
        for entity in graph.all_entities() {
            if namespace.is_empty() || entity.namespace() == namespace {
                proto.messages.push(Self::entity_to_message(entity));
            }
        }

        // Convert resources to messages
        for resource in graph.all_resources() {
            if namespace.is_empty() || resource.namespace() == namespace {
                proto.messages.push(Self::resource_to_message(resource));
            }
        }

        // Sort messages by name for deterministic output
        proto.messages.sort_by(|a, b| a.name.cmp(&b.name));

        // Auto-detect and add Well-Known Type imports
        proto.add_wkt_imports();

        proto
    }

    /// Project with options for a projection contract.
    pub fn project_with_options(
        graph: &Graph,
        namespace: &str,
        package: &str,
        projection_name: &str,
        include_governance: bool,
    ) -> ProtoFile {
        let mut proto = Self::project(graph, namespace, package);
        proto.metadata.projection_name = projection_name.to_string();

        if include_governance {
            proto.messages.extend(Self::generate_governance_messages());
        }

        // Re-add WKT imports in case governance messages need them
        proto.add_wkt_imports();

        proto
    }

    /// Convert an Entity to a ProtoMessage.
    fn entity_to_message(entity: &Entity) -> ProtoMessage {
        let mut msg = ProtoMessage::new(to_pascal_case(entity.name()));
        msg.comments.push(format!("SEA Entity: {}", entity.name()));
        msg.comments.push(format!("Namespace: {}", entity.namespace()));

        let mut field_number = 1u32;

        // Add id field (always first)
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unique identifier".to_string()],
        });
        field_number += 1;

        // Add name field
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Entity name".to_string()],
        });
        field_number += 1;

        // Add attributes sorted alphabetically for deterministic output
        let mut sorted_attrs: BTreeMap<&String, &Value> = BTreeMap::new();
        for (key, value) in entity.attributes() {
            sorted_attrs.insert(key, value);
        }

        for (key, value) in sorted_attrs {
            msg.fields.push(ProtoField {
                name: to_snake_case(key),
                number: field_number,
                proto_type: infer_proto_type_from_value(value),
                repeated: matches!(value, Value::Array(_)),
                optional: true,
                comments: vec![],
            });
            field_number += 1;
        }

        msg
    }

    /// Convert a Resource to a ProtoMessage.
    fn resource_to_message(resource: &Resource) -> ProtoMessage {
        let mut msg = ProtoMessage::new(to_pascal_case(resource.name()));
        msg.comments.push(format!("SEA Resource: {}", resource.name()));
        msg.comments.push(format!("Unit: {}", resource.unit().symbol()));

        let mut field_number = 1u32;

        // Add id field
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unique identifier".to_string()],
        });
        field_number += 1;

        // Add name field
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Resource name".to_string()],
        });
        field_number += 1;

        // Add quantity field with unit comment
        msg.fields.push(ProtoField {
            name: "quantity".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::Double),
            repeated: false,
            optional: true,
            comments: vec![format!("Quantity in {}", resource.unit().symbol())],
        });
        field_number += 1;

        // Add unit field
        msg.fields.push(ProtoField {
            name: "unit".to_string(),
            number: field_number,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec!["Unit of measurement".to_string()],
        });
        field_number += 1;

        // Add attributes
        let mut sorted_attrs: BTreeMap<&String, &Value> = BTreeMap::new();
        for (key, value) in resource.attributes() {
            sorted_attrs.insert(key, value);
        }

        for (key, value) in sorted_attrs {
            msg.fields.push(ProtoField {
                name: to_snake_case(key),
                number: field_number,
                proto_type: infer_proto_type_from_value(value),
                repeated: matches!(value, Value::Array(_)),
                optional: true,
                comments: vec![],
            });
            field_number += 1;
        }

        msg
    }

    /// Generate standard governance messages.
    fn generate_governance_messages() -> Vec<ProtoMessage> {
        let mut messages = Vec::new();

        // PolicyViolation message
        let mut violation = ProtoMessage::new("PolicyViolation");
        violation.comments.push("Represents a policy violation event".to_string());
        violation.fields = vec![
            ProtoField {
                name: "policy_name".to_string(),
                number: 1,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Name of the violated policy".to_string()],
            },
            ProtoField {
                name: "entity_id".to_string(),
                number: 2,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["ID of the entity that violated the policy".to_string()],
            },
            ProtoField {
                name: "severity".to_string(),
                number: 3,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Severity level (error, warn, info)".to_string()],
            },
            ProtoField {
                name: "message".to_string(),
                number: 4,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Human-readable violation message".to_string()],
            },
            ProtoField {
                name: "timestamp".to_string(),
                number: 5,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["When the violation occurred".to_string()],
            },
        ];
        messages.push(violation);

        // MetricEvent message
        let mut metric = ProtoMessage::new("MetricEvent");
        metric.comments.push("Represents a metric measurement event".to_string());
        metric.fields = vec![
            ProtoField {
                name: "metric_name".to_string(),
                number: 1,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["Name of the metric".to_string()],
            },
            ProtoField {
                name: "value".to_string(),
                number: 2,
                proto_type: ProtoType::Scalar(ScalarType::Double),
                repeated: false,
                optional: false,
                comments: vec!["Measured value".to_string()],
            },
            ProtoField {
                name: "unit".to_string(),
                number: 3,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: true,
                comments: vec!["Unit of measurement".to_string()],
            },
            ProtoField {
                name: "timestamp".to_string(),
                number: 4,
                proto_type: ProtoType::Scalar(ScalarType::String),
                repeated: false,
                optional: false,
                comments: vec!["When the measurement was taken".to_string()],
            },
        ];
        messages.push(metric);

        messages
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Convert a string to PascalCase.
fn to_pascal_case(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().to_string() + &chars.as_str().to_lowercase(),
                None => String::new(),
            }
        })
        .collect()
}

/// Convert a string to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let mut prev_is_uppercase = false;

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 && !prev_is_uppercase {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap_or(c));
            prev_is_uppercase = true;
        } else if c.is_alphanumeric() {
            result.push(c);
            prev_is_uppercase = false;
        } else {
            if !result.is_empty() && !result.ends_with('_') {
                result.push('_');
            }
            prev_is_uppercase = false;
        }
    }

    result.trim_matches('_').to_string()
}

/// Convert a string to SCREAMING_SNAKE_CASE.
fn to_screaming_snake_case(s: &str) -> String {
    to_snake_case(s).to_uppercase()
}

// ============================================================================
// Compatibility Enforcement
// ============================================================================

/// Compatibility mode for schema evolution.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum CompatibilityMode {
    /// Only additions allowed - strictest mode for public APIs
    Additive,
    /// Removals become reserved fields - default for internal APIs
    #[default]
    Backward,
    /// All changes allowed - for breaking releases
    Breaking,
}

impl std::fmt::Display for CompatibilityMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CompatibilityMode::Additive => write!(f, "additive"),
            CompatibilityMode::Backward => write!(f, "backward"),
            CompatibilityMode::Breaking => write!(f, "breaking"),
        }
    }
}

impl std::str::FromStr for CompatibilityMode {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "additive" | "strict" => Ok(CompatibilityMode::Additive),
            "backward" | "backwards" | "default" => Ok(CompatibilityMode::Backward),
            "breaking" | "none" => Ok(CompatibilityMode::Breaking),
            _ => Err(format!("Unknown compatibility mode: {}", s)),
        }
    }
}

/// A compatibility violation found during schema comparison.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompatibilityViolation {
    /// The message name where the violation occurred
    pub message_name: String,
    /// The field name involved (if applicable)
    pub field_name: Option<String>,
    /// The field number involved (if applicable)
    pub field_number: Option<u32>,
    /// Type of violation
    pub violation_type: ViolationType,
    /// Human-readable description
    pub description: String,
}

/// Types of compatibility violations.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ViolationType {
    /// A field was removed
    FieldRemoved,
    /// A field number was reused with a different name/type
    FieldNumberReused,
    /// A field type was changed
    FieldTypeChanged,
    /// A field was renamed (same number, different name)
    FieldRenamed,
    /// A message was removed
    MessageRemoved,
    /// A required field was added (breaking in proto3)
    RequiredFieldAdded,
}

impl std::fmt::Display for ViolationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ViolationType::FieldRemoved => write!(f, "field_removed"),
            ViolationType::FieldNumberReused => write!(f, "field_number_reused"),
            ViolationType::FieldTypeChanged => write!(f, "field_type_changed"),
            ViolationType::FieldRenamed => write!(f, "field_renamed"),
            ViolationType::MessageRemoved => write!(f, "message_removed"),
            ViolationType::RequiredFieldAdded => write!(f, "required_field_added"),
        }
    }
}

/// Result of a compatibility check.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompatibilityResult {
    /// Whether the schemas are compatible under the given mode
    pub is_compatible: bool,
    /// The mode used for checking
    pub mode: CompatibilityMode,
    /// List of violations found
    pub violations: Vec<CompatibilityViolation>,
    /// Suggested fixes (reserved fields to add)
    pub suggested_reserved_numbers: BTreeMap<String, Vec<u32>>,
    /// Suggested reserved names
    pub suggested_reserved_names: BTreeMap<String, Vec<String>>,
}

impl CompatibilityResult {
    /// Create a compatible (empty) result.
    pub fn compatible(mode: CompatibilityMode) -> Self {
        Self {
            is_compatible: true,
            mode,
            violations: Vec::new(),
            suggested_reserved_numbers: BTreeMap::new(),
            suggested_reserved_names: BTreeMap::new(),
        }
    }

    /// Check if there are any violations.
    pub fn has_violations(&self) -> bool {
        !self.violations.is_empty()
    }

    /// Format violations as a human-readable report.
    pub fn to_report(&self) -> String {
        let mut out = String::new();
        out.push_str(&format!("Compatibility Check (mode: {})\n", self.mode));
        out.push_str(&format!("Result: {}\n", if self.is_compatible { "PASS" } else { "FAIL" }));
        
        if !self.violations.is_empty() {
            out.push_str(&format!("\nViolations ({}):\n", self.violations.len()));
            for v in &self.violations {
                out.push_str(&format!("  - [{}] {}: {}\n", v.violation_type, v.message_name, v.description));
            }
        }

        if !self.suggested_reserved_numbers.is_empty() {
            out.push_str("\nSuggested Reserved Fields:\n");
            for (msg, nums) in &self.suggested_reserved_numbers {
                let nums_str: Vec<String> = nums.iter().map(|n| n.to_string()).collect();
                out.push_str(&format!("  message {}: reserved {};\n", msg, nums_str.join(", ")));
            }
        }

        out
    }
}

/// Schema compatibility checker.
pub struct CompatibilityChecker;

impl CompatibilityChecker {
    /// Check compatibility between an old and new ProtoFile.
    ///
    /// # Arguments
    /// * `old` - The previous schema version
    /// * `new` - The new schema version  
    /// * `mode` - The compatibility mode to enforce
    ///
    /// # Returns
    /// A CompatibilityResult with violations and suggested fixes.
    pub fn check(old: &ProtoFile, new: &ProtoFile, mode: CompatibilityMode) -> CompatibilityResult {
        let mut result = CompatibilityResult::compatible(mode);

        // Build lookup maps for old schema
        let old_messages: BTreeMap<&str, &ProtoMessage> = old
            .messages
            .iter()
            .map(|m| (m.name.as_str(), m))
            .collect();

        let new_messages: BTreeMap<&str, &ProtoMessage> = new
            .messages
            .iter()
            .map(|m| (m.name.as_str(), m))
            .collect();

        // Check for removed messages
        for (name, _old_msg) in &old_messages {
            if !new_messages.contains_key(name) {
                result.violations.push(CompatibilityViolation {
                    message_name: name.to_string(),
                    field_name: None,
                    field_number: None,
                    violation_type: ViolationType::MessageRemoved,
                    description: format!("Message '{}' was removed", name),
                });
            }
        }

        // Check each message that exists in both
        for (name, old_msg) in &old_messages {
            if let Some(new_msg) = new_messages.get(name) {
                Self::check_message(old_msg, new_msg, &mut result);
            }
        }

        // Determine if compatible based on mode
        result.is_compatible = match mode {
            CompatibilityMode::Breaking => true, // Always compatible in breaking mode
            CompatibilityMode::Backward => {
                // Compatible if no field number reuse or type changes
                !result.violations.iter().any(|v| {
                    matches!(v.violation_type, ViolationType::FieldNumberReused | ViolationType::FieldTypeChanged)
                })
            }
            CompatibilityMode::Additive => {
                // Any removal or change is incompatible
                result.violations.is_empty()
            }
        };

        result
    }

    /// Check compatibility between two messages.
    fn check_message(old: &ProtoMessage, new: &ProtoMessage, result: &mut CompatibilityResult) {
        // Build field maps by number and by name
        let old_by_number: BTreeMap<u32, &ProtoField> = old
            .fields
            .iter()
            .map(|f| (f.number, f))
            .collect();

        let new_by_number: BTreeMap<u32, &ProtoField> = new
            .fields
            .iter()
            .map(|f| (f.number, f))
            .collect();

        let old_by_name: BTreeMap<&str, &ProtoField> = old
            .fields
            .iter()
            .map(|f| (f.name.as_str(), f))
            .collect();

        // Check for removed fields
        for (number, old_field) in &old_by_number {
            if !new_by_number.contains_key(number) {
                result.violations.push(CompatibilityViolation {
                    message_name: old.name.clone(),
                    field_name: Some(old_field.name.clone()),
                    field_number: Some(*number),
                    violation_type: ViolationType::FieldRemoved,
                    description: format!(
                        "Field '{}' (number {}) was removed",
                        old_field.name, number
                    ),
                });

                // Suggest reserving this field number
                result
                    .suggested_reserved_numbers
                    .entry(old.name.clone())
                    .or_default()
                    .push(*number);

                result
                    .suggested_reserved_names
                    .entry(old.name.clone())
                    .or_default()
                    .push(old_field.name.clone());
            }
        }

        // Check for field number reuse with different name/type
        for (number, new_field) in &new_by_number {
            if let Some(old_field) = old_by_number.get(number) {
                // Check name change
                if old_field.name != new_field.name {
                    result.violations.push(CompatibilityViolation {
                        message_name: old.name.clone(),
                        field_name: Some(new_field.name.clone()),
                        field_number: Some(*number),
                        violation_type: ViolationType::FieldRenamed,
                        description: format!(
                            "Field number {} renamed from '{}' to '{}'",
                            number, old_field.name, new_field.name
                        ),
                    });
                }

                // Check type change
                if old_field.proto_type != new_field.proto_type {
                    result.violations.push(CompatibilityViolation {
                        message_name: old.name.clone(),
                        field_name: Some(new_field.name.clone()),
                        field_number: Some(*number),
                        violation_type: ViolationType::FieldTypeChanged,
                        description: format!(
                            "Field '{}' type changed from {} to {}",
                            new_field.name,
                            old_field.proto_type.to_proto_string(),
                            new_field.proto_type.to_proto_string()
                        ),
                    });
                }
            } else {
                // New field - check if it reuses a previously removed name
                if old_by_name.contains_key(new_field.name.as_str()) {
                    let old_field = old_by_name[new_field.name.as_str()];
                    if old_field.number != *number {
                        result.violations.push(CompatibilityViolation {
                            message_name: old.name.clone(),
                            field_name: Some(new_field.name.clone()),
                            field_number: Some(*number),
                            violation_type: ViolationType::FieldNumberReused,
                            description: format!(
                                "Field '{}' changed number from {} to {}",
                                new_field.name, old_field.number, number
                            ),
                        });
                    }
                }
            }
        }
    }

    /// Apply compatibility fixes to a new ProtoFile based on an old one.
    ///
    /// This adds reserved field numbers and names for removed fields.
    pub fn apply_backward_compatibility(old: &ProtoFile, new: &mut ProtoFile) {
        let result = Self::check(old, new, CompatibilityMode::Backward);

        // Apply suggested reserved numbers
        for msg in &mut new.messages {
            if let Some(reserved_nums) = result.suggested_reserved_numbers.get(&msg.name) {
                for num in reserved_nums {
                    if !msg.reserved_numbers.contains(num) {
                        msg.reserved_numbers.push(*num);
                    }
                }
                msg.reserved_numbers.sort();
            }

            if let Some(reserved_names) = result.suggested_reserved_names.get(&msg.name) {
                for name in reserved_names {
                    if !msg.reserved_names.contains(name) {
                        msg.reserved_names.push(name.clone());
                    }
                }
                msg.reserved_names.sort();
            }
        }
    }
}

/// File-based schema history storage.
pub struct SchemaHistory {
    /// Directory where schema history is stored
    history_dir: std::path::PathBuf,
}

impl SchemaHistory {
    /// Create a new SchemaHistory with the given directory.
    pub fn new(history_dir: impl Into<std::path::PathBuf>) -> Self {
        Self {
            history_dir: history_dir.into(),
        }
    }

    /// Get the path for a schema file.
    fn schema_path(&self, package: &str) -> std::path::PathBuf {
        let filename = format!("{}.json", package.replace('.', "_"));
        self.history_dir.join(filename)
    }

    /// Load the previous schema for a package.
    pub fn load(&self, package: &str) -> Result<Option<ProtoFile>, String> {
        let path = self.schema_path(package);
        if !path.exists() {
            return Ok(None);
        }

        let content = std::fs::read_to_string(&path)
            .map_err(|e| format!("Failed to read schema history: {}", e))?;

        let proto: ProtoFile = serde_json::from_str(&content)
            .map_err(|e| format!("Failed to parse schema history: {}", e))?;

        Ok(Some(proto))
    }

    /// Save a schema to history.
    pub fn save(&self, proto: &ProtoFile) -> Result<(), String> {
        // Ensure directory exists
        std::fs::create_dir_all(&self.history_dir)
            .map_err(|e| format!("Failed to create history directory: {}", e))?;

        let path = self.schema_path(&proto.package);
        let content = serde_json::to_string_pretty(proto)
            .map_err(|e| format!("Failed to serialize schema: {}", e))?;

        std::fs::write(&path, content)
            .map_err(|e| format!("Failed to write schema history: {}", e))?;

        Ok(())
    }

    /// Check compatibility and optionally apply fixes.
    pub fn check_and_update(
        &self,
        new: &mut ProtoFile,
        mode: CompatibilityMode,
        apply_fixes: bool,
    ) -> Result<CompatibilityResult, String> {
        let old = self.load(&new.package)?;

        let result = match old {
            Some(ref old_proto) => {
                if apply_fixes && mode == CompatibilityMode::Backward {
                    CompatibilityChecker::apply_backward_compatibility(old_proto, new);
                }
                CompatibilityChecker::check(old_proto, new, mode)
            }
            None => CompatibilityResult::compatible(mode),
        };

        // Save the new schema if compatible (or in breaking mode)
        if result.is_compatible || mode == CompatibilityMode::Breaking {
            self.save(new)?;
        }

        Ok(result)
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("hello_world"), "HelloWorld");
        assert_eq!(to_pascal_case("my-entity"), "MyEntity");
        assert_eq!(to_pascal_case("already PascalCase"), "AlreadyPascalcase");
        assert_eq!(to_pascal_case("UPPERCASE"), "Uppercase");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(to_snake_case("myEntity"), "my_entity");
        assert_eq!(to_snake_case("already_snake"), "already_snake");
        // Consecutive uppercase chars become lowercase without underscore separation
        assert_eq!(to_snake_case("XMLParser"), "xmlparser");
        assert_eq!(to_snake_case("PaymentID"), "payment_id");
    }

    #[test]
    fn test_to_screaming_snake_case() {
        assert_eq!(to_screaming_snake_case("MyEnum"), "MY_ENUM");
        assert_eq!(to_screaming_snake_case("StatusCode"), "STATUS_CODE");
    }

    #[test]
    fn test_map_sea_type_to_proto() {
        assert_eq!(
            map_sea_type_to_proto("string"),
            ProtoType::Scalar(ScalarType::String)
        );
        assert_eq!(
            map_sea_type_to_proto("int"),
            ProtoType::Scalar(ScalarType::Int64)
        );
        assert_eq!(
            map_sea_type_to_proto("boolean"),
            ProtoType::Scalar(ScalarType::Bool)
        );
        assert_eq!(
            map_sea_type_to_proto("timestamp"),
            ProtoType::Message("google.protobuf.Timestamp".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("CustomType"),
            ProtoType::Message("Customtype".to_string())
        );
    }

    #[test]
    fn test_proto_field_to_string() {
        let field = ProtoField {
            name: "my_field".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        };
        assert_eq!(field.to_proto_string(), "string my_field = 1;");

        let optional_field = ProtoField {
            name: "optional_field".to_string(),
            number: 2,
            proto_type: ProtoType::Scalar(ScalarType::Int64),
            repeated: false,
            optional: true,
            comments: vec![],
        };
        assert_eq!(
            optional_field.to_proto_string(),
            "optional int64 optional_field = 2;"
        );

        let repeated_field = ProtoField {
            name: "items".to_string(),
            number: 3,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: true,
            optional: false,
            comments: vec![],
        };
        assert_eq!(repeated_field.to_proto_string(), "repeated string items = 3;");
    }

    #[test]
    fn test_proto_enum_to_string() {
        let mut e = ProtoEnum::new("Status");
        e.add_value("STATUS_ACTIVE");
        e.add_value("STATUS_INACTIVE");

        let output = e.to_proto_string();
        assert!(output.contains("enum Status {"));
        assert!(output.contains("STATUS_UNSPECIFIED = 0;"));
        assert!(output.contains("STATUS_ACTIVE = 1;"));
        assert!(output.contains("STATUS_INACTIVE = 2;"));
    }

    #[test]
    fn test_proto_message_to_string() {
        let mut msg = ProtoMessage::new("Person");
        msg.fields.push(ProtoField {
            name: "name".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        msg.fields.push(ProtoField {
            name: "age".to_string(),
            number: 2,
            proto_type: ProtoType::Scalar(ScalarType::Int32),
            repeated: false,
            optional: true,
            comments: vec![],
        });

        let output = msg.to_proto_string();
        assert!(output.contains("message Person {"));
        assert!(output.contains("string name = 1;"));
        assert!(output.contains("optional int32 age = 2;"));
    }

    #[test]
    fn test_proto_file_to_string() {
        let mut proto = ProtoFile::new("test.package");
        proto.metadata.projection_name = "TestProjection".to_string();
        proto.metadata.source_namespace = "test".to_string();

        let mut msg = ProtoMessage::new("TestMessage");
        msg.fields.push(ProtoField {
            name: "id".to_string(),
            number: 1,
            proto_type: ProtoType::Scalar(ScalarType::String),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        proto.messages.push(msg);

        let output = proto.to_proto_string();
        assert!(output.contains("syntax = \"proto3\";"));
        assert!(output.contains("package test.package;"));
        assert!(output.contains("message TestMessage {"));
        assert!(output.contains("string id = 1;"));
    }

    #[test]
    fn test_entity_to_message() {
        use serde_json::json;

        let mut entity = Entity::new_with_namespace("Warehouse", "logistics");
        entity.set_attribute("capacity", json!(5000));
        entity.set_attribute("location", json!("Building A"));

        let msg = ProtobufEngine::entity_to_message(&entity);

        assert_eq!(msg.name, "Warehouse");
        assert!(msg.fields.iter().any(|f| f.name == "id"));
        assert!(msg.fields.iter().any(|f| f.name == "name"));
        assert!(msg.fields.iter().any(|f| f.name == "capacity"));
        assert!(msg.fields.iter().any(|f| f.name == "location"));

        // Check field numbers are sequential
        let numbers: Vec<u32> = msg.fields.iter().map(|f| f.number).collect();
        assert_eq!(numbers, vec![1, 2, 3, 4]); // id, name, capacity, location (sorted)
    }

    #[test]
    fn test_governance_messages() {
        let messages = ProtobufEngine::generate_governance_messages();
        assert_eq!(messages.len(), 2);

        let violation = messages.iter().find(|m| m.name == "PolicyViolation");
        assert!(violation.is_some());

        let metric = messages.iter().find(|m| m.name == "MetricEvent");
        assert!(metric.is_some());
    }

    // ========================================================================
    // Well-Known Type Tests
    // ========================================================================

    #[test]
    fn test_wkt_type_name() {
        assert_eq!(WellKnownType::Timestamp.type_name(), "google.protobuf.Timestamp");
        assert_eq!(WellKnownType::Duration.type_name(), "google.protobuf.Duration");
        assert_eq!(WellKnownType::Any.type_name(), "google.protobuf.Any");
        assert_eq!(WellKnownType::Struct.type_name(), "google.protobuf.Struct");
        assert_eq!(WellKnownType::Empty.type_name(), "google.protobuf.Empty");
        assert_eq!(WellKnownType::Int64Value.type_name(), "google.protobuf.Int64Value");
    }

    #[test]
    fn test_wkt_import_path() {
        assert_eq!(WellKnownType::Timestamp.import_path(), "google/protobuf/timestamp.proto");
        assert_eq!(WellKnownType::Duration.import_path(), "google/protobuf/duration.proto");
        assert_eq!(WellKnownType::Any.import_path(), "google/protobuf/any.proto");
        assert_eq!(WellKnownType::Struct.import_path(), "google/protobuf/struct.proto");
        assert_eq!(WellKnownType::Value.import_path(), "google/protobuf/struct.proto");
        assert_eq!(WellKnownType::Empty.import_path(), "google/protobuf/empty.proto");
        assert_eq!(WellKnownType::Int64Value.import_path(), "google/protobuf/wrappers.proto");
        assert_eq!(WellKnownType::StringValue.import_path(), "google/protobuf/wrappers.proto");
    }

    #[test]
    fn test_wkt_from_type_name() {
        assert_eq!(WellKnownType::from_type_name("google.protobuf.Timestamp"), Some(WellKnownType::Timestamp));
        assert_eq!(WellKnownType::from_type_name("google.protobuf.Duration"), Some(WellKnownType::Duration));
        assert_eq!(WellKnownType::from_type_name("google.protobuf.Any"), Some(WellKnownType::Any));
        assert_eq!(WellKnownType::from_type_name("google.protobuf.StringValue"), Some(WellKnownType::StringValue));
        assert_eq!(WellKnownType::from_type_name("SomeOtherType"), None);
    }

    #[test]
    fn test_map_sea_type_to_wkt() {
        // Timestamp types
        assert_eq!(
            map_sea_type_to_proto("timestamp"),
            ProtoType::Message("google.protobuf.Timestamp".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("datetime"),
            ProtoType::Message("google.protobuf.Timestamp".to_string())
        );

        // Duration types
        assert_eq!(
            map_sea_type_to_proto("duration"),
            ProtoType::Message("google.protobuf.Duration".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("timespan"),
            ProtoType::Message("google.protobuf.Duration".to_string())
        );

        // Dynamic types
        assert_eq!(
            map_sea_type_to_proto("any"),
            ProtoType::Message("google.protobuf.Any".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("json"),
            ProtoType::Message("google.protobuf.Struct".to_string())
        );

        // Empty type
        assert_eq!(
            map_sea_type_to_proto("void"),
            ProtoType::Message("google.protobuf.Empty".to_string())
        );

        // Nullable/optional types
        assert_eq!(
            map_sea_type_to_proto("optional_string"),
            ProtoType::Message("google.protobuf.StringValue".to_string())
        );
        assert_eq!(
            map_sea_type_to_proto("nullable_int"),
            ProtoType::Message("google.protobuf.Int64Value".to_string())
        );
    }

    #[test]
    fn test_add_wkt_imports() {
        let mut proto = ProtoFile::new("test");

        // Add a message with a Timestamp field
        let mut msg = ProtoMessage::new("Event");
        msg.fields.push(ProtoField {
            name: "created_at".to_string(),
            number: 1,
            proto_type: ProtoType::Message("google.protobuf.Timestamp".to_string()),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        msg.fields.push(ProtoField {
            name: "duration".to_string(),
            number: 2,
            proto_type: ProtoType::Message("google.protobuf.Duration".to_string()),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        proto.messages.push(msg);

        proto.add_wkt_imports();

        assert!(proto.imports.contains(&"google/protobuf/timestamp.proto".to_string()));
        assert!(proto.imports.contains(&"google/protobuf/duration.proto".to_string()));
    }

    #[test]
    fn test_wkt_imports_in_proto_string() {
        let mut proto = ProtoFile::new("test.wkt");

        let mut msg = ProtoMessage::new("AuditLog");
        msg.fields.push(ProtoField {
            name: "timestamp".to_string(),
            number: 1,
            proto_type: ProtoType::Message("google.protobuf.Timestamp".to_string()),
            repeated: false,
            optional: false,
            comments: vec![],
        });
        proto.messages.push(msg);
        proto.add_wkt_imports();

        let output = proto.to_proto_string();
        assert!(output.contains("import \"google/protobuf/timestamp.proto\";"));
    }

    #[test]
    fn test_wkt_no_duplicate_imports() {
        let mut proto = ProtoFile::new("test");

        // Add multiple messages using the same WKT
        let mut msg1 = ProtoMessage::new("Event1");
        msg1.fields.push(ProtoField {
            name: "time1".to_string(),
            number: 1,
            proto_type: ProtoType::Message("google.protobuf.Timestamp".to_string()),
            repeated: false,
            optional: false,
            comments: vec![],
        });

        let mut msg2 = ProtoMessage::new("Event2");
        msg2.fields.push(ProtoField {
            name: "time2".to_string(),
            number: 1,
            proto_type: ProtoType::Message("google.protobuf.Timestamp".to_string()),
            repeated: false,
            optional: false,
            comments: vec![],
        });

        proto.messages.push(msg1);
        proto.messages.push(msg2);
        proto.add_wkt_imports();

        // Should only have one timestamp import
        let timestamp_count = proto.imports.iter()
            .filter(|i| i.contains("timestamp"))
            .count();
        assert_eq!(timestamp_count, 1);
    }

    // ========================================================================
    // Compatibility Tests
    // ========================================================================

    fn make_test_proto(messages: Vec<ProtoMessage>) -> ProtoFile {
        ProtoFile {
            package: "test.package".to_string(),
            syntax: "proto3".to_string(),
            imports: vec![],
            options: ProtoOptions::default(),
            enums: vec![],
            messages,
            metadata: ProtoMetadata::default(),
        }
    }

    fn make_test_message(name: &str, fields: Vec<ProtoField>) -> ProtoMessage {
        ProtoMessage {
            name: name.to_string(),
            fields,
            nested_messages: vec![],
            nested_enums: vec![],
            reserved_numbers: vec![],
            reserved_names: vec![],
            comments: vec![],
        }
    }

    fn make_test_field(name: &str, number: u32, proto_type: ProtoType) -> ProtoField {
        ProtoField {
            name: name.to_string(),
            number,
            proto_type,
            repeated: false,
            optional: false,
            comments: vec![],
        }
    }

    #[test]
    fn test_compatibility_no_changes() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                make_test_field("name", 2, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = old.clone();

        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Additive);
        assert!(result.is_compatible);
        assert!(result.violations.is_empty());
    }

    #[test]
    fn test_compatibility_field_added() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                make_test_field("name", 2, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        // Adding fields is compatible in all modes
        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Additive);
        assert!(result.is_compatible);
        assert!(result.violations.is_empty());
    }

    #[test]
    fn test_compatibility_field_removed_additive() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                make_test_field("name", 2, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        // Removing fields is NOT compatible in additive mode
        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Additive);
        assert!(!result.is_compatible);
        assert_eq!(result.violations.len(), 1);
        assert_eq!(result.violations[0].violation_type, ViolationType::FieldRemoved);
    }

    #[test]
    fn test_compatibility_field_removed_backward() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                make_test_field("name", 2, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        // Removing fields IS compatible in backward mode (with warnings)
        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Backward);
        assert!(result.is_compatible); // Still compatible, just has violations
        assert!(!result.violations.is_empty());
        
        // Should suggest reserving the field
        assert!(result.suggested_reserved_numbers.contains_key("Person"));
        assert!(result.suggested_reserved_numbers["Person"].contains(&2));
    }

    #[test]
    fn test_compatibility_type_change() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("age", 1, ProtoType::Scalar(ScalarType::Int32)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("age", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        // Type changes are NOT compatible in backward mode
        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Backward);
        assert!(!result.is_compatible);
        assert!(result.violations.iter().any(|v| v.violation_type == ViolationType::FieldTypeChanged));
    }

    #[test]
    fn test_compatibility_breaking_mode() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("uuid", 1, ProtoType::Scalar(ScalarType::Int64)),
            ],
        )]);

        // Breaking mode allows everything
        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Breaking);
        assert!(result.is_compatible);
        // Violations are still reported for informational purposes
        assert!(!result.violations.is_empty());
    }

    #[test]
    fn test_apply_backward_compatibility() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                make_test_field("name", 2, ProtoType::Scalar(ScalarType::String)),
                make_test_field("email", 3, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let mut new = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("id", 1, ProtoType::Scalar(ScalarType::String)),
                // name (2) removed
                // email (3) removed
                make_test_field("phone", 4, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        CompatibilityChecker::apply_backward_compatibility(&old, &mut new);

        // Should have added reserved numbers
        let person = &new.messages[0];
        assert!(person.reserved_numbers.contains(&2));
        assert!(person.reserved_numbers.contains(&3));
        assert!(person.reserved_names.contains(&"name".to_string()));
        assert!(person.reserved_names.contains(&"email".to_string()));
    }

    #[test]
    fn test_compatibility_message_removed() {
        let old = make_test_proto(vec![
            make_test_message("Person", vec![]),
            make_test_message("Address", vec![]),
        ]);

        let new = make_test_proto(vec![
            make_test_message("Person", vec![]),
        ]);

        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Additive);
        assert!(!result.is_compatible);
        assert!(result.violations.iter().any(|v| {
            v.violation_type == ViolationType::MessageRemoved && v.message_name == "Address"
        }));
    }

    #[test]
    fn test_compatibility_result_report() {
        let old = make_test_proto(vec![make_test_message(
            "Person",
            vec![
                make_test_field("name", 1, ProtoType::Scalar(ScalarType::String)),
            ],
        )]);

        let new = make_test_proto(vec![make_test_message(
            "Person",
            vec![],
        )]);

        let result = CompatibilityChecker::check(&old, &new, CompatibilityMode::Backward);
        let report = result.to_report();

        assert!(report.contains("Compatibility Check"));
        assert!(report.contains("field_removed"));
        assert!(report.contains("Person"));
    }

    #[test]
    fn test_compatibility_mode_parsing() {
        assert_eq!("additive".parse::<CompatibilityMode>().unwrap(), CompatibilityMode::Additive);
        assert_eq!("backward".parse::<CompatibilityMode>().unwrap(), CompatibilityMode::Backward);
        assert_eq!("breaking".parse::<CompatibilityMode>().unwrap(), CompatibilityMode::Breaking);
        assert!("invalid".parse::<CompatibilityMode>().is_err());
    }
}
