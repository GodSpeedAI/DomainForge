# Export to Protobuf

This guide explains how to export SEA models to Protocol Buffers (`.proto`) files for use with gRPC services, binary serialization, and cross-language contracts.

## Prerequisites

- `sea` CLI installed ([install guide](./install-cli.md))
- A valid `.sea` model file

## Quick Start

Export an entity model to a `.proto` file:

```bash
sea project --format protobuf model.sea output.proto
```

This generates a complete `.proto` file with:

- All entities as Protobuf messages
- All resources as Protobuf messages
- Type mappings from SEA types to proto types
- Metadata header with generation timestamp

## Example

Given a SEA model (`payment.sea`):

```sea
Namespace "com.example.payments"

Entity "Customer" {
    name: String
    email: String
    balance: Money
}

Entity "Payment" {
    amount: Money
    status: String
    timestamp: DateTime
}

Resource "PaymentRequest" USD
```

Running:

```bash
sea project --format protobuf payment.sea payment.proto
```

Produces:

```protobuf
// Generated by SEA Projection Framework
// Projection: protobuf
// Source Namespace: com.example.payments
// Generated At: 2025-12-14T20:00:00Z
// DO NOT EDIT - This file is auto-generated

syntax = "proto3";

package com.example.payments;

option java_package = "com.example.payments";
option java_multiple_files = true;
option go_package = "github.com/example/payments";

import "google/protobuf/timestamp.proto";

message Customer {
  string balance = 1;
  string email = 2;
  string name = 3;
}

message Payment {
  string amount = 1;
  string status = 2;
  google.protobuf.Timestamp timestamp = 3;
}

message PaymentRequest {
  string id = 1;
  double value = 2;
  string unit = 3;
}
```

## Options

### Include gRPC Services

Generate gRPC service definitions from Flow patterns:

```bash
sea project --format protobuf --include-services model.sea output.proto
```

This converts SEA Flows into gRPC RPC methods:

| SEA Construct           | gRPC Output            |
| ----------------------- | ---------------------- |
| Flow destination entity | Service name           |
| Flow name               | RPC method name        |
| Flow resource           | Request/Response types |

### Multi-File Output

Split output by namespace for large models:

```bash
sea project --format protobuf --multi-file --output-dir ./proto model.sea
```

This creates a directory structure:

```
proto/
├── common/
│   └── common.proto
├── payments/
│   └── payments.proto
└── customers/
    └── customers.proto
```

### Specify Package Name

Override the default package:

```bash
sea project --format protobuf --package "org.example.api" model.sea output.proto
```

### Language-Specific Options

Set language-specific proto options:

```bash
sea project --format protobuf \
  --option java_package="com.example.api" \
  --option go_package="github.com/example/api" \
  --option java_multiple_files=true \
  model.sea output.proto
```

## Type Mapping

SEA types are mapped to Protobuf types as follows:

| SEA Type         | Protobuf Type               |
| ---------------- | --------------------------- |
| `String`         | `string`                    |
| `Int`            | `int64`                     |
| `Float`          | `double`                    |
| `Bool`           | `bool`                      |
| `Date`           | `google.protobuf.Timestamp` |
| `DateTime`       | `google.protobuf.Timestamp` |
| `Duration`       | `google.protobuf.Duration`  |
| `UUID`           | `string`                    |
| `Money`          | Custom `Money` message      |
| `List<T>`        | `repeated T`                |
| `Optional<T>`    | `optional T`                |
| Entity reference | Message reference           |

## Buf.build Integration

If `buf` CLI is installed, use it for linting and validation:

```bash
# Lint generated protos
sea project --format protobuf --buf-lint model.sea output.proto

# Check breaking changes
sea project --format protobuf --buf-breaking --against ./previous model.sea output.proto
```

If `buf` is not installed, these flags emit a warning and continue.

## Programmatic Usage

### Rust

```rust
use sea_core::parser::parse_source;
use sea_core::parser::ast::ast_to_graph;
use sea_core::projection::protobuf::ProtobufEngine;

let source = std::fs::read_to_string("model.sea")?;
let ast = parse_source(&source)?;
let graph = ast_to_graph(&ast)?;

let proto_file = ProtobufEngine::project(&graph, "my_namespace", "com.example");
println!("{}", proto_file.to_proto_string());
```

### Python

```python
from sea_core import parse_source, ast_to_graph
from sea_core.projection import protobuf_engine

source = open("model.sea").read()
ast = parse_source(source)
graph = ast_to_graph(ast)

proto = protobuf_engine.project(graph, "my_namespace", "com.example")
print(proto.to_proto_string())
```

### TypeScript

```typescript
import { parseSource, astToGraph } from "sea-core";
import { ProtobufEngine } from "sea-core/projection";

const source = fs.readFileSync("model.sea", "utf-8");
const ast = parseSource(source);
const graph = astToGraph(ast);

const protoFile = ProtobufEngine.project(graph, "my_namespace", "com.example");
console.log(protoFile.toProtoString());
```

## Compatibility Checking

The engine supports schema compatibility checking to prevent breaking changes:

### Compatibility Modes

| Mode       | Allowed Changes                           |
| ---------- | ----------------------------------------- |
| `Additive` | Only additions (new fields/messages)      |
| `Backward` | Additions + safe removals (with reserved) |
| `Breaking` | Any changes allowed                       |

### CLI Usage

```bash
# Check compatibility against previous version
sea project --format protobuf --compatibility additive \
  --against ./previous/output.proto \
  model.sea output.proto
```

## gRPC Streaming

SEA Flows can specify streaming mode for gRPC:

```sea
// Unary (default)
Flow from Client to Server of Request

// Server streaming
Flow @streaming from Client to Server of EventStream

// Client streaming
Flow @client_streaming from Client to Server of DataChunks

// Bidirectional
Flow @bidirectional from Client to Server of ChatMessage
```

Generated proto:

```protobuf
service ServerService {
  rpc ProcessRequest(Request) returns (RequestResponse);
  rpc StreamEvents(EventStreamRequest) returns (stream EventStream);
  rpc UploadChunks(stream DataChunks) returns (DataChunksResponse);
  rpc Chat(stream ChatMessage) returns (stream ChatMessage);
}
```

## Troubleshooting

### Missing Well-Known Types

If you see errors about missing `google.protobuf.*` types:

1. Ensure your protoc includes path has the Google WKT:

   ```bash
   protoc -I /usr/include -I . --go_out=. output.proto
   ```

2. Or install the WKT package for your language.

### Field Number Stability

Field numbers are assigned deterministically by alphabetical order of field names. To maintain backward compatibility:

- Don't rename fields
- Don't remove fields without using `reserved`
- Add new fields at the end (they'll get higher numbers)

### Import Errors

For multi-file output, ensure your import paths match the generated structure:

```bash
protoc -I ./proto --go_out=. proto/**/*.proto
```

## See Also

- [SDS-001: Protobuf Projection Engine](../specs/SDS-001-protobuf-projection-engine.md) - System design spec
- [ADR-003: Protobuf as Projection Target](../specs/ADR-003-protobuf-projection-target.md) - Architecture decision
- [Protobuf Advanced Features Plan](../plans/protobuf_advanced_features_plan.md) - Roadmap
- [CLI Commands Reference](../reference/cli-commands.md) - All CLI options
